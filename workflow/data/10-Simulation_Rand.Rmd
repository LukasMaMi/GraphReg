---
title: "01-Simulation_Rand"
date: "Compiled at `r format(Sys.time(), '%Y-%m-%d %H:%M:%S', tz = 'UTC')` UTC"
output: github_document
params:
  name: "01-Simulation_Rand" # change if you rename file
---

```{r}
library(MASS)
library(pulsar)
library(Matrix)
library(igraph)
library(huge)

generator_rand <- function (n, p, prob, vis = FALSE, verbose = TRUE) 
{
    gcinfo(FALSE)
    if (verbose) 
        cat("Generating data from the multivariate normal 
            distribution with the random graph structure....")

    prob = sqrt(prob/2) * (prob < 0.5) + 
      (1 - sqrt(0.5 - 0.5 * prob)) * (prob >= 0.5)
    
    theta = matrix(0, p, p)
        tmp = matrix(runif(p^2, 0, 0.5), p, p) #set threshold
        tmp = tmp + t(tmp)
        theta[tmp < prob] = 1 #thresholding: If prob greater than 0.5 than edge is present (1)
        rm(tmp)
        gc()
    
# Ensure no self-loops
diag(theta) = 0 
# Create a symmetric matrix with random values in the range [-1, 1] for off-diagonals
random_matrix <- matrix(runif(p^2, -1, 1), p, p)
omega = theta * (random_matrix + t(random_matrix)) / 2  
# Set the diagonal values to be larger than the sum of absolute values of off-diagonals
for (i in 1:p) {
  omega[i, i] = sum(abs(omega[-i, i])) + 0.1  # Offset slightly for strict positivity
}

max_val <- max(abs(omega)) # Find the maximum absolute value in omega
omega <- omega / max_val # Normalize to range [-1, 1]

# Inverse of omega to get sigma (covariance matrix)
sigma = solve(omega) 
omega = solve(sigma)
# Generate multivariate normal samples
x = MASS::mvrnorm(n, mu = rep(0, p), Sigma = sigma)
# Estimate the covariance matrix from the generated samples
sigmahat = cov(x)

if (vis == TRUE) {
        fullfig = par(mfrow = c(2, 2), pty = "s", omi = c(0.3, 
            0.3, 0.3, 0.3), mai = c(0.3, 0.3, 0.3, 0.3))
        fullfig[1] = image(theta, col = gray.colors(256), main = "Adjacency Matrix")
        fullfig[2] = image(sigma, col = gray.colors(256), main = "Covariance Matrix")
        g = graph.adjacency(theta, mode = "undirected", diag = FALSE)
        layout.grid = layout.fruchterman.reingold(g)
        fullfig[3] = plot(g, layout = layout.grid, edge.color = "gray50", 
            vertex.color = "red", vertex.size = 3, vertex.label = NA, 
            main = "Graph Pattern")
        fullfig[4] = image(sigmahat, col = gray.colors(256), 
            main = "Empirical Matrix")
        rm(fullfig, g, layout.grid)
        gc()
    }
    
    if (verbose) 
        cat("done.\n")
    rm(vis, verbose)
    gc()
    
    sim = list(data = x, sigma = sigma, sigmahat = sigmahat, 
    omega = omega, theta = Matrix(theta, sparse = TRUE), 
    sparsity = sum(theta)/(p * (p - 1))) #Sparsity level = number of present edges divided by number of potential edges p x p.
    class(sim) = "sim"
    return(sim)
}

```


```{r}
#Set Parameters
n <- 400 
p <- 100 

#Subsampled dataset size 
b = (floor(10*sqrt(n)))/n
#Number of Subsamples N
N = 20

prob <- 3/p #For p = 40, Prob = 0.075

ER <- generator_rand(n = n, p = p, prob = prob, vis = TRUE)
ER_data <- ER$data

#ER_data 
ER$omega
range(ER$omega)
ER$theta
ER$sparsity
prob

huge.plot(ER$theta)
```

## Session info
```{r}
sessionInfo()
```





