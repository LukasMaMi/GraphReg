---
title: "00-Simulation_Hub"
date: "Compiled at `r format(Sys.time(), '%Y-%m-%d %H:%M:%S', tz = 'UTC')` UTC"
output: gitHub_document
params:
  name: "00-Simulation_Hub" # change if you rename file
---

# Simulations for Hub Graphs

## Generator Function for Hub Graphs
```{r}
library(MASS)
library(Matrix)
library(igraph)
library(huge)
library(orca)
library(pulsar)

generator_Hub <- function (n, p, rho, g, vis, verbose) 
{
    gcinfo(FALSE)
    if (verbose) 
        cat("Generating data from the multivariate normal distribution with the Hub graph structure....")
  
  g.large = p%%g #Rest Funktion
    g.small = g - g.large
    n.small = floor(p/g)
    n.large = n.small + 1
    g.list = c(rep(n.small, g.small), rep(n.large, g.large))
    g.ind = rep(c(1:g), g.list)
    rm(g.large, g.small, n.small, n.large, g.list)
    gc()
    
    theta = matrix(0, p, p) #Here Theta defined (pxp matrix with entries "0")
  
    for (i in 1:g) {
        tmp = which(g.ind == i)
        theta[tmp[1], tmp] = 1
        theta[tmp, tmp[1]] = 1
        rm(tmp)
        gc()
    }
  
    diag(theta) = 0
    omega = theta * rho
    diag(omega) = 1 #Set diagonal of precision matrix to 1 (Liu et al.)
    sigma = solve(omega) #Knackpunkt! Das ist nun das Sigma, welche zu unserem simulierten theta gehÃ¶rt.
    x = mvrnorm(n, rep(0, p), sigma) #Dieses Sigma wird schlussendlich verwendet, um die Daten zu simulieren!!!
    sigmahat = cov(x) #Empirical covariance matrix
    
    if (vis == TRUE) {
        fullfig = par(mfrow = c(2, 2), pty = "s", omi = c(0.3, 
            0.3, 0.3, 0.3), mai = c(0.3, 0.3, 0.3, 0.3))
        fullfig[1] = image(theta, col = gray.colors(256), main = "Adjacency Matrix")
        fullfig[2] = image(sigma, col = gray.colors(256), main = "Covariance Matrix")
        g = graph.adjacency(theta, mode = "undirected", diag = FALSE)
        layout.grid = layout.fruchterman.reingold(g)
        fullfig[3] = plot(g, layout = layout.grid, edge.color = "gray50", 
            vertex.color = "red", vertex.size = 3, vertex.label = NA, 
            main = "Graph Pattern")
        fullfig[4] = image(sigmahat, col = gray.colors(256), 
            main = "Empirical Matrix")
        rm(fullfig, g, layout.grid)
        gc()
    }
    if (verbose) 
        cat("done.\n")
    rm(vis, verbose)
    gc()
    sim = list(data = x, sigma = sigma, sigmahat = sigmahat, 
        omega = omega, theta = theta, 
        act_sparsity = sum(theta)/(p * (p - 1)))
    class(sim) = "sim"
    return(sim)
}
```


## Data Generation
```{r}

# Define directory path
#dir_path <- "C:/R Projekte/StARS_Simulations/workflow/Storage_Simulation_Hub"
dir_path <- "/Users/bropc/Documents/LMU/Master Statistics and Data Science/Masterarbeit/R Master/StARS_Simulations/workflow/Storage_Simulation_Hub"

# Manually set the number of repetitions
num_repetitions <- 1 

# Specify configurations
configs <- list(
  list(n=800, p=40)
  #list(n=400, p=100)
  #list(n=200, p=200)
  #,list(n=100, p=400)
)

#Hub_setting_path <- "C:/R Projekte/StARS_Simulations/workflow/Storage_Settings/" 
Hub_setting_path <- "/Users/bropc/Documents/LMU/Master Statistics and Data Science/Masterarbeit/R Master/StARS_Simulations/workflow/Storage_Settings/"
hub_settings_file <- file.path(Hub_setting_path, "Hub_settings.RData")
save(num_repetitions, configs, dir_path, file = hub_settings_file)


#Size of each Hub group
s <- 20

#Off-diagonal elements
#rho <- (1/(s+1))
#rho <- 0.1 # 1)
#rho <- 0.15 # 2)
rho <- 0.2

# Set up outer loop for repetitions 
for(rep in 1:num_repetitions) {
  
  # Set up inner loop for configurations
  for(cfg in configs) {
    
    n <- cfg$n
    p <- cfg$p
    #lam_min <- cfg$lam_min
    
    #Number of Hub groups
    J <- floor(p/s)
    
    #Subsampled dataset size 
    b = (floor(10*sqrt(n)))/n
    #Number of Subsamples N
    N = 20

    Hub <- generator_Hub(n = n, p = p, rho = rho, g = J, vis = FALSE, verbose = TRUE)
    
    Hub_data <- Hub$data
    true_graph <- Hub$theta
    act_sparsity <- Hub$act_sparsity
    
    #Lambda path
    #mlam  <- getMaxCov(scale(dat$data))
    #lams  <- getLamPath(mlam, 1e-3, 15)
    #lams  <- getLamPath(getMaxCov(cor(dat$data)), 1e-1, 5)
    lambda_path  <- getLamPath(max = getMaxCov(Hub_data), min = 0.1, len = 20, log = TRUE)
    lambda <- list(lambda=lambda_path)
    
    # Define the name of the file to save, including the directory path
    file_name <- paste0(dir_path, "/Hub_rep_", rep, "_n_", n, "_p_", p, ".RData")
    
    # Save the Hub data to the file
    save(Hub_data, true_graph, lambda, lambda_path, b, N, act_sparsity, file = file_name)


  }
}

print("Hubs generated and saved!")


```



##Check true graphs
```{r}
# Define the directory path where your files are stored
dir_path <- "/Users/bropc/Documents/LMU/Master Statistics and Data Science/Masterarbeit/R Master/StARS_Simulations/workflow/Storage_Simulation_Hub"

# List all RData files in the directory
file_true_Hub <- list.files(dir_path, pattern = "\\.RData$", full.names = TRUE)

# Adjacency matrices of true graph
extract_true_graph <- function(file_path) {
  e <- new.env()
  load(file_path, envir = e)
  return(e$true_graph)
}

# Extract and store the true graphs
true_graphs <- lapply(file_true_Hub, extract_true_graph)
true_graphs

image(true_graphs[[1]], col = gray.colors(256), main = "First True Graph")

# Sparsity of true graphs
extract_sparsity_true_graph <- function(file_path) {
  e <- new.env()
  load(file_path, envir = e)
  return(e$sparsity)
}

# Extract and store the true graphs
true_sparsity <- lapply(file_true_Hub, extract_sparsity_true_graph)
true_sparsity 

```

## Session info
```{r}
sessionInfo()
```





```{r}

library(pulsar)
library(orca)

n = 100
p = 400

#Size of each Hub group
s <- 20
#Off-diagonal elements
#rho <- (1/(s+1))
rho <- 0.15

    #Number of Hub groups
    J <- floor(p/s)
    
    #Subsampled dataset size 
    b = (floor(10*sqrt(n)))/n
    
    #Number of Subsamples N
    N = 20


 Hub <- generator_Hub(n = n, p = p, rho = rho, g = J, vis = FALSE, verbose = TRUE)
    
    Hub_data <- Hub$data
    true_graph <- Hub$theta
    act_sparsity <- Hub$act_sparsity
    
  #Lambda path
  lambda_path  <- getLamPath(max = getMaxCov(Hub_data), min = 0.01, len = 40)
  lambda <- list(lambda=lambda_path)
  
    
#Define QUIC as method of choice for stars and gstars
  library(QUIC)
  
  quicr <- function(data, lambda, ...) {
    S <- cov(data)
    est <- QUIC(S, rho = 1, path = lambda, msg = 0, tol = 1e-2, ...)
    est$path <- lapply(seq(length(lambda)), function(i) {
    ## convert precision array to adj list
    tmp <- est$X[,,i]; diag(tmp) <- 0
    tmp <- ifelse(tmp != 0, 1, 0)
    return(tmp)
    })
    est
  }
  
  #Run pulsar package
  library(orca)
  out.p <- pulsar(
        data = Hub_data,
        fun = quicr,
        fargs = (lambda = lambda),
        criterion = c('stars', 'gcd'),
        thresh = 0.1,
        subsample.ratio = b,
        rep.num = N,
        seed = NULL,
        lb.stars = TRUE,
        ub.stars = TRUE,
        ncores = 1,
        refit = FALSE
  )
  
  
  
  
  
  
  plot(out.p, legends = F, scale = T)
  
  #Get optimal index for gcd
  lam_gam <- get.opt.index(out.p, criterion = "gcd")
  opt.index(out.p, criterion = "gcd") <- lam_gam
  
  fit  <- refit(out.p, criterion = c("stars", "gcd"))
  
  
  out.p
  
  fit
  
  stars_graph <- fit[["refit"]][["stars"]]
  gstars_graph <- fit[["refit"]][["gcd"]]
  
  stars_index <- out.p[["stars"]][["opt.index"]]
  best_lambda_stars <- round(lambda_path[stars_index], 3)
  
  gstars_index <- out.p[["gcd"]][["opt.index"]]
  best_lambda_gstars <- round(lambda_path[gstars_index], 3)
  
  fit
  (act_sparsity_stars = sum(stars_graph) / (p * (p - 1)))
  (act_sparsity_gstars = sum(gstars_graph) / (p * (p - 1)))
  
  # Oracle procedure
  oracle_results <- quicr(Hub_data, lambda_path)
  
  # F1-Score as criterium for Oracle
  f1_score <- function(predicted, actual) {
      true_positives = sum(predicted[lower.tri(predicted)] & actual[lower.tri(actual)])
      predicted_positives = sum(predicted[lower.tri(predicted)])
      actual_positives = sum(actual[lower.tri(actual)])
  
      precision = ifelse(predicted_positives > 0, true_positives / predicted_positives, 0)
      recall = ifelse(actual_positives > 0, true_positives / actual_positives, 0)
      f1 = ifelse((precision + recall) > 0, 2 * precision * recall / (precision + recall), 0)
  
      return(f1)
  }
  
  # Best lambda Oracle
  best_lambda_index <- which.max(sapply(1:length(lambda_path), function(i) {
    estimated_graph <- oracle_results$path[[i]]
    f1_score(estimated_graph, true_graph)
  }))
  
  best_lambda_oracle <- lambda_path[best_lambda_index]
  
  # Extract oracle precision matrix for the best lambda:
  oracle_graph <- oracle_results$X[,,best_lambda_index]
  
  # Convert precision matrix to adjacency matrix
  oracle_graph <- ifelse(oracle_graph != 0, 1, 0)
  diag(oracle_graph) <- 0


library(orca)

  configs <- list(
  list(n=800, p=40, lam_min = 0.01),
  list(n=400, p=100, lam_min = 0.01),
  list(n=200, p=200, lam_min = 0.01),
  list(n=100, p=400, lam_min = 0.0000001)
)
```

