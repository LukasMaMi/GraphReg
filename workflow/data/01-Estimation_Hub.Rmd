---
title: "01-Estimation_Hub"
output: gitHub_document
---


# Run StARS, G-StARS and Oracle
```{r}

library(pulsar)

#Hub_setting_path <- "C:/R Projekte/StARS_Simulations/workflow/Storage_Settings/"
Hub_setting_path <- "/Users/bropc/Documents/LMU/Master Statistics and Data Science/Masterarbeit/R Master/StARS_Simulations/workflow/Storage_Settings/"
hub_settings_file <- file.path(Hub_setting_path, "Hub_settings.RData")
load(hub_settings_file)


# 1. Generate list of file names based on configs
get_filename <- function(config, rep, prefix = "Hub") {
  return(sprintf("%s_rep_%d_n_%d_p_%d.RData", prefix, rep, config$n, config$p))
}

  # 2. Loop over each file, load dataset, and compute adjacency matrices
  for(rep in 1:num_repetitions) {
    for(i in seq_along(configs)) {
      # Get filename for the current configuration and repetition
      filename <- get_filename(configs[[i]], rep)
      
      # Load the dataset
      load(paste0(dir_path, "/", filename))
  
      
  #GLASSO
  #est <- batch.pulsar(dat$data, huge::huge, fargs,
            #rep.num=3, lb.stars=TRUE, wkdir=tmpdir, refit=FALSE))
      
  #Define QUIC as method of choice for stars and gstars
  #library(QUIC)
  
  #quicr <- function(data, lambda, ...) {
   # S <- cov(data)
    #est <- QUIC(S, rho = 1, path = lambda, msg = 0, tol = 1e-2, ...)
    #est$path <- lapply(seq(length(lambda)), function(i) {
    ## convert precision array to adj list
    #tmp <- est$X[,,i]; diag(tmp) <- 0
    #tmp <- ifelse(tmp != 0, 1, 0)
    #return(tmp)
    #})
    #est
  #}
  
    #library(BigQuic)
    #quicr <- function(data, lambda, ...) {
    #est  <- BigQuic::BigQuic(data, lambda=lambda, epsilon = 1e-2, use_ram = F, seed = seed)
    #est$path <-  lapply(seq(length(lambda)), function(i) {
    ## convert precision array to adj list
                #tmp <- est$X[,,i]; diag(tmp); diag(tmp) <- 0
                #tmp <- ifelse(tmp != 0, 1, 0)
                #return(tmp)
    #})
    #est
    #}
    
    #library(BigQuic)
    #quicr <- function(data, lambda, seed=NULL) {
    #est  <- BigQuic::BigQuic(data, lambda=lambda, epsilon=1e-2, use_ram=TRUE, seed=seed)
    #est <- setNames(lapply(ls(envir=est), mget, envir=attr(unclass(est), '.xData')), ls(envir=est))
    #path <-  lapply(seq(length(lambda)), function(i) {
                #tmp <- est$precision_matrices[[1]][[i]]; diag(tmp) <- 0
                #tmp <- ifelse(tmp != 0, 1, 0)
                #as(tmp!=0, "lgCMatrix")
    #})
    #est$path <- path
    #est
    #}
    
    library(BigQuic)
    quicr <- function(data, lambda, ...) {
    p <- ncol(data)
    est <- BigQuic::BigQuic(data, lambda=lambda, epsilon=1e-2, use_ram=TRUE, seed=seed)
    ## convert BigQuic object to named list
    est <- setNames(lapply(ls(envir=est), mget, envir=attr(unclass(est), '.xData')), ls(envir=est))
    path <-  lapply(seq(length(lambda)), function(i) {
                tmp <- est$precision_matrices[[1]][[i]][1:p,1:p]
                diag(tmp) <- 0
                as(tmp!=0, "lMatrix")
                #tmp <- ifelse(tmp != 0, 1, 0)
    })
    est$path <- path
    }
  
  #Run pulsar package
  #library(orca)
  #out.p <- pulsar(
        #data = Hub_data,
        #fun = quicr,
        #fargs = lambda,
        #criterion = c('stars', 'gcd'),
        #thresh = 0.02,
        #subsample.ratio = b,
        #rep.num = N,
        #seed = NULL,
        #lb.stars = TRUE,
        #ub.stars = TRUE,
        #ncores = 1,
        #refit = FALSE
  #)
  
      #Run batch pulsar package
      library(orca)
      out.p <- batch.pulsar(
      data = Hub_data,
      fun = quicr,
      fargs = lambda,
      criterion = c("stars", 'gcd'),
      thresh = 0.1,
      subsample.ratio = b,
      lb.stars = TRUE,
      ub.stars = TRUE,
      rep.num = N,
      seed = NULL,
      wkdir = getwd(),
      regdir = NA,
      init = "init",
      conffile = "",
      job.res = list(),
      cleanup = FALSE,
      refit = FALSE
)
  
  
  # Optimal Index Stars
  stars_index <- out.p[["stars"]][["opt.index"]]
  # Optimal Lambda
  best_lambda_stars <- round(lambda_path[stars_index], 3)
  # Lower Bound
  stars_lb <- out.p[["stars"]][["lb.index"]]
  # Upper Bound
  stars_ub <- out.p[["stars"]][["ub.index"]]

  # Optimal Index Gstars
  lam_gam <- get.opt.index(out.p, criterion = "gcd")
  opt.index(out.p, criterion = "gcd") <- lam_gam
  gstars_index <- out.p[["gcd"]][["opt.index"]][["gcd"]]
  # Optimal Lambda
  best_lambda_gstars <- round(lambda_path[gstars_index], 3)

  
  fit  <- refit(out.p, criterion = c("stars", "gcd"))
  ## Stars
  stars_graph <- fit[["refit"]][["stars"]]
  ## GStars
  gstars_graph <- fit[["refit"]][["gcd"]]
  
  lambd_plot <- plot(out.p, legends = F)
 
  # Oracle procedure
  oracle_results <- quicr(Hub_data, lambda_path)
  
  # F1-Score as criterium for Oracle
  f1_score <- function(predicted, actual) {
      true_positives = sum(predicted[lower.tri(predicted)] & actual[lower.tri(actual)])
      predicted_positives = sum(predicted[lower.tri(predicted)])
      actual_positives = sum(actual[lower.tri(actual)])
  
      precision = ifelse(predicted_positives > 0, true_positives / predicted_positives, 0)
      recall = ifelse(actual_positives > 0, true_positives / actual_positives, 0)
      f1 = ifelse((precision + recall) > 0, 2 * precision * recall / (precision + recall), 0)
  
      return(f1)
  }
  
  # Best lambda Oracle
  oracle_index <- which.max(sapply(1:length(lambda_path), function(i) {
    estimated_graph <- oracle_results$path[[i]]
    f1_score(estimated_graph, true_graph)
  }))
  
  best_lambda_oracle <- lambda_path[oracle_index]
  
  # Extract the oracle precision matrix for the best lambda:
  oracle_graph <- oracle_results$X[,,oracle_index]
  
  # Convert precision matrix to adjacency matrix
  oracle_graph <- ifelse(oracle_graph != 0, 1, 0)
  diag(oracle_graph) <- 0
  
      
  act_sparsity_stars = sum(stars_graph) / (configs[[i]]$p * (configs[[i]]$p - 1))
  act_sparsity_gstars = sum(gstars_graph) / (configs[[i]]$p * (configs[[i]]$p - 1))
  act_sparsity_oracle = sum(oracle_graph) / (configs[[i]]$p * (configs[[i]]$p - 1))
      
  
# Save results to file
#dir_path2 <- "C:/R Projekte/StARS_Simulations/workflow/Storage_Estimation_Hub"
dir_path2 <- "/Users/bropc/Documents/LMU/Master Statistics and Data Science/Masterarbeit/R Master/StARS_Simulations/workflow/Storage_Estimation_Hub"
save(num_repetitions, configs, dir_path, dir_path2, file = hub_settings_file)
result_filename <- get_filename(configs[[i]], rep, prefix="estimation")
save(true_graph, stars_graph, gstars_graph, oracle_graph, act_sparsity, act_sparsity_stars, act_sparsity_gstars, act_sparsity_oracle, best_lambda_oracle, best_lambda_stars, best_lambda_gstars, stars_index, gstars_index, oracle_index, stars_lb, stars_ub, out.p, lambd_plot, file=paste0(dir_path2, "/", ... = result_filename))

  }
}

print("Adjacency matrices for Hub generated and saved!")
```

```{r}

#install.packages("htmltools")
#library(htmltools)

#install.packages("devtools")
#library(devtools)

#install.packages('batchtools')
#library(batchtools)

#install_github("zdk123/pulsar")
#library(pulsar)

#install.packages("BigQuic")
#library(BigQuic)


#Hub_setting_path <- "C:/R Projekte/StARS_Simulations/workflow/Storage_Settings/"
Hub_setting_path <- "/Users/bropc/Documents/LMU/Master Statistics and Data Science/Masterarbeit/R Master/StARS_Simulations/workflow/Storage_Settings/"
hub_settings_file <- file.path(Hub_setting_path, "Hub_settings.RData")
load(hub_settings_file)


# 1. Generate list of file names based on configs
get_filename <- function(config, rep, prefix = "Hub") {
  return(sprintf("%s_rep_%d_n_%d_p_%d.RData", prefix, rep, config$n, config$p))
}

  # 2. Loop over each file, load dataset, and compute adjacency matrices
  for(rep in 1:num_repetitions) {
    for(i in seq_along(configs)) {
      # Get filename for the current configuration and repetition
      filename <- get_filename(configs[[i]], rep)
      
      # Load the dataset
      load(paste0(dir_path, "/", filename))
  
      
    library(BigQuic)
    quicr <- function(data, lambda, seed=NULL) {
    est  <- BigQuic::BigQuic(data, lambda=lambda, epsilon=1e-2, use_ram=TRUE, seed=seed)
    est <- setNames(lapply(ls(envir=est), mget, envir=attr(unclass(est), '.xData')), ls(envir=est))
    path <-  lapply(seq(length(lambda)), function(i) {
    ## convert precision array to adj list
                tmp <- est$precision_matrices[[1]][[i]]; diag(tmp) <- 0
                as(tmp!=0, 1, 0)
                return(tmp)
    })
    est$path <- path
    est
}
      

      
      out.p <- batch.pulsar(Hub_data, fun=quicr, fargs=lambda, rep.num=20,
                criterion=c('stars', 'gcd'), lb.stars=TRUE, ub.stars=TRUE, seed=NULL)

#plot(out.q, legends = F)
  
  
  # Optimal Index Stars
  stars_index <-  opt.index(out.p, 'stars')
  # Optimal Lambda
  best_lambda_stars <- round(lambda_path[stars_index], 3)
  # Lower Bound
  stars_lb <- out.p[["stars"]][["lb.index"]]
  # Upper Bound
  stars_ub <- out.p[["stars"]][["ub.index"]]

  # Optimal Index Gstars
  opt.index(out.p, criterion = "gcd") <- get.opt.index(out.p, criterion = "gcd")
  gstars_index <- opt.index(out.p, 'gcd')
  # Optimal Lambda
  best_lambda_gstars <- round(lambda_path[gstars_index], 3)

  
  fit  <- refit(out.p, criterion = c("stars", "gcd"))
  ## Stars
  stars_graph <- fit[["refit"]][["stars"]]
  ## GStars
  gstars_graph <- fit[["refit"]][["gcd"]]
  
  lambd_plot <- plot(out.p, legends = F)
  
  #starserr <- sum(fit$refit$stars != Hub_data$theta)/p^2
  #gcderr   <- sum(fit$refit$gcd   != Hub_data$theta)/p^2
 
  # Oracle procedure
  oracle_results <- quicr(Hub_data, lambda_path)
  
  # F1-Score as criterium for Oracle
  f1_score <- function(predicted, actual) {
      true_positives = sum(predicted[lower.tri(predicted)] & actual[lower.tri(actual)])
      predicted_positives = sum(predicted[lower.tri(predicted)])
      actual_positives = sum(actual[lower.tri(actual)])
  
      precision = ifelse(predicted_positives > 0, true_positives / predicted_positives, 0)
      recall = ifelse(actual_positives > 0, true_positives / actual_positives, 0)
      f1 = ifelse((precision + recall) > 0, 2 * precision * recall / (precision + recall), 0)
  
      return(f1)
  }
  
  # Best lambda Oracle
  oracle_index <- which.max(sapply(1:length(lambda_path), function(i) {
    estimated_graph <- oracle_results$path[[i]]
    f1_score(estimated_graph, true_graph)
  }))
  
  best_lambda_oracle <- lambda_path[oracle_index]
  
  # Extract the oracle precision matrix for the best lambda:
  oracle_graph <- oracle_results$X[,,oracle_index]
  
  # Convert precision matrix to adjacency matrix
  oracle_graph <- ifelse(oracle_graph != 0, 1, 0)
  diag(oracle_graph) <- 0
  
      
  act_sparsity_stars = sum(stars_graph) / (configs[[i]]$p * (configs[[i]]$p - 1))
  act_sparsity_gstars = sum(gstars_graph) / (configs[[i]]$p * (configs[[i]]$p - 1))
  act_sparsity_oracle = sum(oracle_graph) / (configs[[i]]$p * (configs[[i]]$p - 1))
      
  
# Save results to file
#dir_path2 <- "C:/R Projekte/StARS_Simulations/workflow/Storage_Estimation_Hub"
dir_path2 <- "/Users/bropc/Documents/LMU/Master Statistics and Data Science/Masterarbeit/R Master/StARS_Simulations/workflow/Storage_Estimation_Hub"
save(num_repetitions, configs, dir_path, dir_path2, file = hub_settings_file)
result_filename <- get_filename(configs[[i]], rep, prefix="estimation")
save(true_graph, stars_graph, gstars_graph, oracle_graph, act_sparsity, act_sparsity_stars, act_sparsity_gstars, act_sparsity_oracle, best_lambda_oracle, best_lambda_stars, best_lambda_gstars, stars_index, gstars_index, oracle_index, stars_lb, stars_ub, out.p, lambd_plot, file=paste0(dir_path2, "/", ... = result_filename))

  }
}

print("Adjacency matrices for Hub generated and saved!")
```



## Short evaluation
```{r}
## install.packages('network')
truenet  <- network::network(as.matrix(dat$theta))
starsnet <- network::network(summary(fit.q2$refit$stars))
gcdnet   <- network::network(summary(fit.q2$refit$gcd))
par(mfrow=c(1,3))
coords <- plot(truenet, usearrows=FALSE, main="TRUE")
plot(starsnet, coord=coords, usearrows=FALSE, main="StARS")
plot(gcdnet, coord=coords, usearrows=FALSE, main="gcd+StARS")
```


## Check
```{r}
dir_path2 <- "/Users/bropc/Documents/LMU/Master Statistics and Data Science/Masterarbeit/R Master/StARS_Simulations/workflow/Storage_Estimation_Hub"

# Get a list of all .RData files in the directory
files <- list.files(path = dir_path2, pattern = "n_800_p_40.*\\.RData$", full.names = TRUE)
files <- list.files(path = dir_path2, pattern = "n_400_p_100.*\\.RData$", full.names = TRUE)
files <- list.files(path = dir_path2, pattern = "n_200_p_200.*\\.RData$", full.names = TRUE)

# Check sparsity
for (file in files) {
  load(file)
  print(act_sparsity)
  print(act_sparsity_oracle)
  print(act_sparsity_stars)
  print(act_sparsity_gstars)
}

# Check lambda index
for (file in files) {
  load(file)
  print(oracle_index)
  print(stars_index)
  print(gstars_index)
}

#Check Plot
for (file in files) {
  load(file)
  print(stars_lb)
  print(stars_ub)
  plot(out.p, legends = F)
}

# Check sparsity differences
for (file in files) {
  load(file)
  print(abs(act_sparsity - act_sparsity_oracle))
  print(abs(act_sparsity - act_sparsity_stars))
  print(abs(act_sparsity - act_sparsity_gstars))
}


# Check adjacency matrices
for (file in files) {
  load(file)
  #print(true_graph)
  #print(oracle_graph)
  print(stars_graph)
  #print(gstars_graph)
}


# Check hamming differences in repetition
oracle_graphs <- list()
stars_graphs <- list()
gstars_graphs <- list()

for (i in 1:length(files)) {
  load(files[i])
  oracle_graphs[[i]] <- oracle_graph
  stars_graphs[[i]] <- stars_graph
  gstars_graphs[[i]] <- gstars_graph
}

difference <- list(sum(oracle_graphs[[1]] != oracle_graphs[[2]]), sum(stars_graphs[[1]] != stars_graphs[[2]]), sum(gstars_graphs[[1]] != gstars_graphs[[2]]))
  print(difference)

  
# Check hamming fit
for (file in files) {
  load(file)
  print(sum(true_graph != true_graph))
  print(sum(oracle_graph != true_graph))
  print(sum(stars_graph != true_graph))
  print(sum(gstars_graph != true_graph))
}

  
# Check plots
for (file in files) {
  load(file)
  Hub <- huge.plot(true_graph)
  Hub_oracle <- huge.plot(oracle_graph)
  Hub_stars <- huge.plot(stars_graph)
  #ER_gstars <- huge.plot(gstars_graph)
}


```







```{r}
library(MASS)
library(Matrix)
library(igraph)
library(huge)
library(orca)
library(pulsar)

generator_Hub <- function (n, p, rho, g, vis, verbose) 
{
    gcinfo(FALSE)
    if (verbose) 
        cat("Generating data from the multivariate normal distribution with the Hub graph structure....")
  
  g.large = p%%g #Rest Funktion
    g.small = g - g.large
    n.small = floor(p/g)
    n.large = n.small + 1
    g.list = c(rep(n.small, g.small), rep(n.large, g.large))
    g.ind = rep(c(1:g), g.list)
    rm(g.large, g.small, n.small, n.large, g.list)
    gc()
    
    theta = matrix(0, p, p) #Here Theta defined (pxp matrix with entries "0")
  
    for (i in 1:g) {
        tmp = which(g.ind == i)
        theta[tmp[1], tmp] = 1
        theta[tmp, tmp[1]] = 1
        rm(tmp)
        gc()
    }
  
    diag(theta) = 0
    omega = theta * rho
    diag(omega) = 1 #Set diagonal of precision matrix to 1 (Liu et al.)
    sigma = solve(omega) #Knackpunkt! Das ist nun das Sigma, welche zu unserem simulierten theta gehÃ¶rt.
    x = mvrnorm(n, rep(0, p), sigma) #Dieses Sigma wird schlussendlich verwendet, um die Daten zu simulieren!!!
    sigmahat = cov(x) #Empirical covariance matrix
    
    if (vis == TRUE) {
        fullfig = par(mfrow = c(2, 2), pty = "s", omi = c(0.3, 
            0.3, 0.3, 0.3), mai = c(0.3, 0.3, 0.3, 0.3))
        fullfig[1] = image(theta, col = gray.colors(256), main = "Adjacency Matrix")
        fullfig[2] = image(sigma, col = gray.colors(256), main = "Covariance Matrix")
        g = graph.adjacency(theta, mode = "undirected", diag = FALSE)
        layout.grid = layout.fruchterman.reingold(g)
        fullfig[3] = plot(g, layout = layout.grid, edge.color = "gray50", 
            vertex.color = "red", vertex.size = 3, vertex.label = NA, 
            main = "Graph Pattern")
        fullfig[4] = image(sigmahat, col = gray.colors(256), 
            main = "Empirical Matrix")
        rm(fullfig, g, layout.grid)
        gc()
    }
    if (verbose) 
        cat("done.\n")
    rm(vis, verbose)
    gc()
    sim = list(data = x, sigma = sigma, sigmahat = sigmahat, 
        omega = omega, theta = theta, 
        act_sparsity = sum(theta)/(p * (p - 1)))
    class(sim) = "sim"
    return(sim)
}
```


```{r}

## Funktioniert
s <- 20
rho <- 0.2
n <- 100
p <- 400
J <- floor(p/s)
b = (floor(10*sqrt(n)))/n
N = 20

Hub <- generator_Hub(n = n, p = p, rho = rho, g = J, vis = FALSE, verbose = TRUE)
Hub_data <- Hub$data

#Lambda path
maxCov <- getMaxCov(Hub_data)
min <- 5e-2*maxCov
lambda_path  <- getLamPath(max = maxCov, min = min, len = 30, log = TRUE)
lambda <- list(lambda=lambda_path)
lambda

library(BigQuic)
quicr <- function(data, lambda, seed=NULL) {
    est  <- BigQuic::BigQuic(data, lambda=lambda, epsilon=1e-2, use_ram=TRUE, seed=seed)
    est <- setNames(lapply(ls(envir=est), mget, envir=attr(unclass(est), '.xData')), ls(envir=est))
    path <-  lapply(seq(length(lambda)), function(i) {
                tmp <- est$precision_matrices[[1]][[i]]; diag(tmp) <- 0
                as(tmp!=0, "lgCMatrix")
    })
    est$path <- path
    est
}


#nc    <- if (.Platform$OS.type == 'unix') 2 else 1
#out.p <- pulsar(Hub_data, fun=quicr, fargs=lambda, rep.num=10,
                #criterion='stars', lb.stars=TRUE, ub.stars=TRUE,
                #ncores=nc, seed=10010)

#out.p <- batch.pulsar(Hub_data, fun=quicr, fargs=lambda, rep.num=10,
                #criterion='stars', lb.stars=TRUE, ub.stars=TRUE, 
                #seed=10010)
out.p <- batch.pulsar(Hub_data, fun=quicr, fargs=lambda, rep.num = N,
                criterion=c('stars', 'gcd'), lb.stars=TRUE, ub.stars=TRUE, 
                seed = NULL)
#out.p <- update(out.p, criterion=c('stars', 'gcd'),
                     #lb.stars=TRUE, ub.stars=TRUE)
    


# Optimal Index Stars
stars_index <-  opt.index(out.p, 'stars')
stars_index
# Optimal Lambda
best_lambda_stars <- round(lambda_path[stars_index], 3)
best_lambda_stars
# Lower Bound
stars_lb <- out.p[["stars"]][["lb.index"]]
stars_lb
# Upper Bound
stars_ub <- out.p[["stars"]][["ub.index"]]
stars_ub

# Optimal Index Gstars
opt.index(out.p, criterion = "gcd") <- get.opt.index(out.p, criterion = "gcd")
gstars_index <- opt.index(out.p, 'gcd')
gstars_index
# Optimal Lambda
best_lambda_gstars <- round(lambda_path[gstars_index], 3)
best_lambda_gstars


fit  <- refit(out.p, criterion = c("stars", "gcd"))
## Stars
stars_graph <- fit[["refit"]][["stars"]]
stars_graph 
## GStars
gstars_graph <- fit[["refit"]][["gcd"]]
gstars_graph

lambd_plot <- plot(out.p, legends = F)

```
```{r}

  # Specify configurations
  configs <- list(
    list(n=800, p=40)
    #list(n=400, p=100)
    #list(n=200, p=200)
    #,list(n=100, p=400)
  )


dir_path <- "/Users/bropc/Documents/LMU/Master Statistics and Data Science/Masterarbeit/R Master/StARS_Simulations/workflow/Storage_Simulation_Hub/"

# Set up inner loop for configurations
for(cfg in configs) {
    
  n <- cfg$n
  p <- cfg$p
  s <- 20
  J <- floor(p/s)
  b = (floor(10*sqrt(n)))/n
  N = 20
  rho <- 0.2

  Hub <- generator_Hub(n = n, p = p, rho = rho, g = J, vis = FALSE, verbose = TRUE)
  Hub_data <- Hub$data

  lambda_path  <- getLamPath(max = getMaxCov(Hub_data), min = 0.01, len = 20, log = TRUE)
  lambda <- list(lambda=lambda_path)

  file_name <- paste0(dir_path, "Hub_data.RData")
  save(Hub_data, lambda, b, N, configs, file = file_name)
}



Hub_Storage <- file.path("/Users/bropc/Documents/LMU/Master Statistics and Data Science/Masterarbeit/R Master/StARS_Simulations/workflow/Storage_Simulation_Hub/", "Hub_data.RData")
load(Hub_Storage)


for(cfg in configs) {

  
    library(BigQuic)
    quicr <- function(data, lambda, seed=NULL) {
    est  <- BigQuic::BigQuic(data, lambda=lambda, epsilon=1e-2, use_ram=TRUE, seed=seed)
    est <- setNames(lapply(ls(envir=est), mget, envir=attr(unclass(est), '.xData')), ls(envir=est))
    path <-  lapply(seq(length(lambda)), function(i) {
                tmp <- est$precision_matrices[[1]][[i]]; diag(tmp) <- 0
                tmp <- ifelse(tmp != 0, 1, 0)
    })
    est$path <- path
    est
    }
    
    library(batchtools)
    out.p <- batch.pulsar(Hub_data, fun=quicr, fargs=lambda, rep.num=10,
                criterion='stars', lb.stars=TRUE, ub.stars=TRUE, 
                seed=10010)
 
    out.bp <- update(out.p, criterion=c('stars', 'gcd'),
                     lb.stars=TRUE, ub.stars=TRUE)
    
    
}

print("Adjacency matrices for Hub generated and saved!")


```








```{r}
  # Optimal Index Stars
  stars_index <-  opt.index(out.p, 'stars')
  # Optimal Lambda
  best_lambda_stars <- round(lambda_path[stars_index], 3)
  # Lower Bound
  stars_lb <- out.p[["stars"]][["lb.index"]]
  # Upper Bound
  stars_ub <- out.p[["stars"]][["ub.index"]]

  # Optimal Index Gstars
  opt.index(out.p, criterion = "gcd") <- get.opt.index(out.p, criterion = "gcd")
  gstars_index <- opt.index(out.p, 'gcd')
  # Optimal Lambda
  best_lambda_gstars <- round(lambda_path[gstars_index], 3)

  
  fit  <- refit(out.p, criterion = c("stars", "gcd"))
  ## Stars
  stars_graph <- fit[["refit"]][["stars"]]
  ## GStars
  gstars_graph <- fit[["refit"]][["gcd"]]
  
  lambd_plot <- plot(out.p, legends = F)
```


