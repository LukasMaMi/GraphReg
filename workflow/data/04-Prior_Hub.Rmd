---
title: "04-Prior_Hub"
output: github_document
---


```{r}
library(MASS)
library(Matrix)
library(igraph)
library(huge)
library(pulsar)


generator_Hub <- function (n, p, rho, g, vis, verbose) 
{
    gcinfo(FALSE)
    if (verbose) 
        cat("Generating data from the multivariate normal distribution with the Hub graph structure....")
  
  g.large = p%%g #Rest Funktion
    g.small = g - g.large
    n.small = floor(p/g)
    n.large = n.small + 1
    g.list = c(rep(n.small, g.small), rep(n.large, g.large))
    g.ind = rep(c(1:g), g.list)
    rm(g.large, g.small, n.small, n.large, g.list)
    gc()
    
    theta = matrix(0, p, p) #Here Theta defined (pxp matrix with entries "0")
  
    for (i in 1:g) {
        tmp = which(g.ind == i)
        theta[tmp[1], tmp] = 1
        theta[tmp, tmp[1]] = 1
        rm(tmp)
        gc()
    }
  
    diag(theta) = 0
    omega = theta * rho
    diag(omega) = 1 #Set diagonal of precision matrix to 1 (Liu et al.)
    sigma = cov2cor(omega) #Knackpunkt! Das ist nun das Sigma, welche zu unserem simulierten theta gehört.
    x = mvrnorm(n, rep(0, p), sigma) #Dieses Sigma wird schlussendlich verwendet, um die Daten zu simulieren!!!
    sigmahat = cor(x) #Empirical covariance matrix
    
    if (vis == TRUE) {
        fullfig = par(mfrow = c(2, 2), pty = "s", omi = c(0.3, 
            0.3, 0.3, 0.3), mai = c(0.3, 0.3, 0.3, 0.3))
        fullfig[1] = image(theta, col = gray.colors(256), main = "Adjacency Matrix")
        fullfig[2] = image(sigma, col = gray.colors(256), main = "Covariance Matrix")
        g = graph.adjacency(theta, mode = "undirected", diag = FALSE)
        layout.grid = layout.fruchterman.reingold(g)
        fullfig[3] = plot(g, layout = layout.grid, edge.color = "gray50", 
            vertex.color = "red", vertex.size = 3, vertex.label = NA, 
            main = "Graph Pattern")
        fullfig[4] = image(sigmahat, col = gray.colors(256), 
            main = "Empirical Matrix")
        rm(fullfig, g, layout.grid)
        gc()
    }
    if (verbose) 
        cat("done.\n")
    rm(vis, verbose)
    gc()
    sim = list(data = x, sigma = sigma, sigmahat = sigmahat, 
        omega = omega, theta = as(as(as(theta, "lMatrix"), "generalMatrix"), "CsparseMatrix"),
        act_sparsity = sum(theta)/(p * (p - 1))) #-1 because every node can connect to p-1 nodes (discarding diag)
    class(sim) = "sim"
    return(sim)
}


n <- 800 # Samples
p <- 40 # Dimensions
s <- 20    # Size Hub Group
J <- floor(p/s) # Number of Hubs
b = ifelse(n > 144, (floor(10*sqrt(n)))/n, 0.8) # Size Subsamples (Ratio)
N = 5 # Number of Repetitions
rho <- 0.20 # Off-Diagonal Effect Strength

Hub <- generator_Hub(n = n, p = p, rho = rho, g = J, vis = FALSE, verbose = TRUE)
Hub_data <- Hub$data
true_graph <- Hub$theta
act_sparsity <- Hub$act_sparsity

maxCov <- getMaxCov(Hub_data)
lambda_path  <- getLamPath(max = maxCov, min = 0.01, len = 20) #,log = TRUE
lambda <- list(lambda=lambda_path)


# Using QUIC
library(BigQuic)
quicr <- function(data, lambda) {
    p <- ncol(data)
    est  <- BigQuic(X = data, lambda=lambda, epsilon=1e-2, use_ram=TRUE, seed = NULL)
    est <- setNames(lapply(ls(envir=est), mget, envir=attr(unclass(est), '.xData')), ls(envir=est))
    path <-  lapply(seq(length(lambda)), function(i) {
                tmp <- est$precision_matrices[[1]][[i]][1:p,1:p]
                diag(tmp) <- 0
                as(tmp!=0, "lMatrix")
    })
    est$path <- path
    est
}

quicargs <- list(lambda = lambda_path)    
  
library(batchtools)
library(pulsar)
#options(mc.cores = 2) #Speed up by setting number of cores available
#options(batchtools.progress=TRUE, batchtools.verbose = TRUE)

time1    <- system.time(    
out.p <- Graphreg(
  data = Hub_data, 
  fun = quicr, 
  fargs = quicargs, 
  rep.num = N,
  thresh = 0.05,
  subsample.ratio = b,
  criterion=c('stars', 'gcd', 'gcd_prior'), 
  lb.stars = TRUE, 
  ub.stars = TRUE, 
  seed = FALSE,
  refit = TRUE,
  prior_graph = true_graph,
  method = c("spearman", "latentcor", "kendall"),
  five_node = FALSE,
  use_pseudo_count = TRUE
))

out.p

stop()

for (crit in out.p$criterion) {
  if (startsWith(crit, "gcd_")) {
    opt.index(out.p, criterion = crit) <- get.opt.index(out.p, criterion = crit)
  }
}

out.p

refit <- refit.pulsar(out.p)

stop()

plot(out.p, legends = T, show = c("stars", "gcd_pseudo_kendall", "gcd_prior_pseudo_kendall", "gcd_kendall", "gcd_prior_kendall"))


```













```{r}
my.gcvec <- function(graph, method, orbind, five_node = FALSE, pseudo_count = FALSE, return_gcm = FALSE) {
  
  orbind <- orbind + 1
  if (length(orbind) < 2) stop("Only one orbit selected, need at least two to calculate graphlet correlations")
  if (any(orbind > 15))   stop("Only 15 orbits, from 4-node graphlets, can be selected")
  if (!method %in% c("kendall", "spearman", "latentcor")) stop("Not supported correlation method is chosen!")
  nx2 <- .adj2elist(graph) # Transform adjacency matrix to nx2 edge matrix
  n <- length(orbind)
  if (ncol(nx2) < 1 || nrow(nx2) < 1) {
      return(rep(0, n*(n-1)/2)) # Return empty vector
  }

  p <- ncol(graph)
  if (five_node == TRUE) { gdm <- orca::count5(nx2)
    } else { gdm <- orca::count4(nx2) # redundant Graphlet Degree Matrix (gdm) px15
  } 
  
  ## expand missing nodes
  buffer <- matrix(0, nrow=p-nrow(gdm), ncol=ncol(gdm)) # Create empty set up
  gdm <- rbind(gdm, buffer) # non-redundant Graphlet Degree Matrix (gdm) px11
  ## warnings here are due to std dev == 0. This almost always occurs for a completely connected
  ## or completely empty graph and can be safely suppressed.
  
  if (pseudo_count == TRUE) {
    ## Add pseudo_count to orb_count
    gdm2 <- rbind(gdm[,orbind]) 
    gdm4 <- modify_orb_count(orb_count = gdm, pseudo_count_range = c(0, 0.1))
    print(gdm)
  } else {
    # add one row of 1s to the orbind matrix to overcome std dev == 0 error problem 
    gdm3 <- rbind(gdm[,orbind],1) 
  }
  
  if (method %in% c("kendall", "spearman")){
  #Then calculate the graphlet correlation matrix with method
  gcm <- suppressWarnings(cor(gdm, method = method))
  }
  
  else if (method == "latentcor") {
  gcm <- suppressMessages(latentcor::latentcor(gdm, method = "approx", use.nearPD = FALSE))
  gcm <- gcm$R
  }
  
  gcv <- gcm[upper.tri(gcm)] # Create a numeric vector of the upper triangle of gcm
  
  if (return_gcm == TRUE) {
    return(gcm)
  } else return(gcv)
}


#################
orbind = c(0, 1, 2, 4, 5, 6, 7, 8, 9, 10, 11)

modify_orb_count <- function(orb_count, pseudo_count_range = c(0, 0.1)) {
  # Validate the orbit_count_range input
  if (length(pseudo_count_range) != 2 || pseudo_count_range[1] >= pseudo_count_range[2]) {
    stop("pseudo_count_range must be a vector of two numbers, where the first is less than the second. 
         \n i.e. pseudo_count_range = c(0, 0.1)")
  }

  # Generate a random matrix with the same dimensions as orb_count
  random_matrix <- matrix(runif(nrow(orb_count) * ncol(orb_count), 
                               min = pseudo_count_range[1], 
                               max = pseudo_count_range[2]), 
                          nrow = nrow(orb_count), 
                          ncol = ncol(orb_count))
  
  # Apply conditional logic to add random noise only to the zero elements of orb_count
  modified_orb_count <- mapply(function(orb_elem, random_elem) {
                               if (orb_elem == 0) orb_elem + random_elem else orb_elem
                             }, orb_count, random_matrix)
  
  # Convert the modified_orb_count to a matrix and set the column names
  modified_orb_count_matrix <- matrix(modified_orb_count, nrow = nrow(orb_count), ncol = ncol(orb_count))
  colnames(modified_orb_count_matrix) <- colnames(orb_count)

  return(modified_orb_count_matrix)
}





#' @keywords internal
.adj2elist <- function(G) {
    if (inherits(G, "sparseMatrix")) {
        G <- Matrix::triu(G, k=1)
        index_i_j <- Matrix::mat2triplet(G)[1:2]
        return(as.data.frame(index_i_j))
    } else {
        p <- ncol(G)
        return(arrayInd(which(as.logical(triu(G))), c(p,p)))
    }
}
```






## Playground
```{r}

modify_orb_count <- function(orb_count, pseudo_count_range = c(0, 0.1)) {
  # Validate the orbit_count_range input
  if (length(pseudo_count_range) != 2 || pseudo_count_range[1] >= pseudo_count_range[2]) {
    stop("pseudo_count_range must be a vector of two numbers, where the first is less than the second. 
         \n i.e. pseudo_count_range = c(0, 0.1)")
  }

  # Generate a random matrix with the same dimensions as orb_count
  random_matrix <- matrix(runif(nrow(orb_count) * ncol(orb_count), 
                               min = pseudo_count_range[1], 
                               max = pseudo_count_range[2]), 
                          nrow = nrow(orb_count), 
                          ncol = ncol(orb_count))
  
  # Apply conditional logic to add random noise only to the zero elements of orb_count
  modified_orb_count <- mapply(function(orb_elem, random_elem) {
                               if (orb_elem == 0) orb_elem + random_elem else orb_elem
                             }, orb_count, random_matrix)
  
  # Convert the modified_orb_count to a matrix and set the column names
  modified_orb_count_matrix <- matrix(modified_orb_count, nrow = nrow(orb_count), ncol = ncol(orb_count))
  colnames(modified_orb_count_matrix) <- colnames(orb_count)

  return(modified_orb_count_matrix)
}


# Warum sind die estimated GCM nicht in der Lage die negative Correlation zu messen?
# Mhm warum sind die GCMs bei Yaveroglu et al NUR positiv korreliert aber niemals negativ? 
#Hub: It semms that orb 0 and 1 are konkurieren and 0 and 6 konkurieren
# VERGLEICHE GCM VS GCM PRIOR um herauszufinden, was makante Unterschiede zwischen ihnen sind. Dann vergleiche GCM PRIOR VS GCM PRIOR PSEUDO um herauszufinden was die unterschiede zwischen ihnen sind und warum PSEUDO besser performt!!!
# Bei Verwendung von Noise sollte hinzufügen von einer Reihe Einsen nicht mehr notwendig sein, Überprüfe das!

graph <- true_graph
graph <- gstars_graph
graph <- out.p[["gcd_spearman"]][["refit"]]

orbind = c(0, 2, 5, 7, 8, 10, 11, 6, 9, 4, 1)+1

orbind = c(4, 5, 8, 9, 10, 11, 0, 1, 2, 6, 7)+1

# orbind = c(0, 2, 5, 7, 8, 10, 11, 6, 9, 4, 1)+1
# orbind = c(0, 2, 5, 7, 8, 10, 11, 6, 9, 4, 1)+1
# orbind = c(0, 2, 5, 7, 8, 10, 11, 6, 9, 4, 1)+1


nx2 <- .adj2elist(graph)
nx2 
n <- length(orbind)
p <- ncol(graph)
orb_count <- orca::count4(nx2) # redundant graphlet degree matrix (gdm) px15
orb_count
buffer <- matrix(0, nrow=p-nrow(orb_count), ncol=ncol(orb_count)) # Create empty set up
buffer
orb_count <- rbind(orb_count, buffer)
orb_count 
orb_count_normal = rbind(orb_count[,orbind],1)
orb_count_normal

orb_count_noise <- modify_orb_count(orb_count_normal, pseudo_count_range = pseudo_count_range)
orb_count_noise

gcm <- suppressWarnings(cor(orb_count_normal, method = "spearman"))
gcm <- suppressMessages(latentcor::latentcor(orb_count_normal, method = "approx", use.nearPD = TRUE))
gcm 

corrplot::corrplot(gcm)

gcv2 <- gcm[upper.tri(gcm)]
gcv1

gcd <- dist(gcv1, gcv2)
gcd






test <- my.gcvec(true_graph, method = "spearman", orbind = orbind, five_node = FALSE,
                                                         pseudo_count = TRUE, return_gcm = TRUE, 
                                                         pseudo_count_range = pseudo_count_range)

test


GCD <- function(gcv1, gcv2){
  res = dist(rbind(gcv1,gcv2))[[1]]
  return(res)
}

GCD(gcv1,gcv2)





```




























